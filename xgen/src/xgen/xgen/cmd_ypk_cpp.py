#! /usr/bin/python
#

from xgen.util import *
from xgen.yxsd import *
from xgen import util
import glob
from jinja2 import Environment, DictLoader

# 2.7
# reload(sys)
#import sys
# sys.setdefaultencoding('utf-8')

import logging
logger = logging.getLogger(__name__)


def ypkcppname(name):
    return 'Y' + cppname(name)


def nodecppname(path):
    if path == 'yNode':
        return path
    elif path == 'yDoc':
        return path
    elif path.startswith('/'):
        path = path[1:]

    name = ''
    for n in path.split(':'):
        name = n
    return 'node' + cppname(name)


def nsprefix(prefix):
    if prefix == '':
        return 'nsMod'
    else:
        return 'ns' + cppname(prefix)


def myindent(indent=0):
    return ' '*4*indent


def mysplit(string, sep):
    return string.split(sep)


def nodename(path):
    if path.startswith('/'):
        return path[1:]

    return path


class CmdYPK(object):
    def __init__(self, inXsdDir, inBundle):
        self.m_mods = {}
        self.m_xsd_dir = inXsdDir
        self.m_bundle = inBundle
        self.initenv()

    def initenv(self):
        mytemplates = {
            "h_ymod": H_YMOD_TEMPLATE,
            "cpp_ymod_base": CPP_YMOD_BASE_TEMPLATE,
            "cpp_ymod": CPP_YMOD_TEMPLATE,
            "h_bundle": H_BUNDLE_TEMPLATE,
            "cpp_bundle": CPP_BUNDLE_TEMPLATE,
        }
        self.m_env = Environment(loader=DictLoader(
            mytemplates), trim_blocks=True, lstrip_blocks=True)
        self.m_env.filters["ypkcppname"] = ypkcppname
        self.m_env.filters["pbname"] = pbname
        self.m_env.filters["cppname"] = cppname
        self.m_env.filters["nodecppname"] = nodecppname
        self.m_env.filters["nodename"] = nodename
        self.m_env.filters["nsprefix"] = nsprefix
        self.m_env.filters["myindent"] = myindent
        self.m_env.filters["mysplit"] = mysplit
        self.m_env.filters["cppnormalize"] = util.cppnormalize
        self.m_env.tests['xSimpleTypeEnum'] = isXSimpleTypeEnum

    def run(self, inDir):
        util.mkdir(inDir)

        path = self.m_xsd_dir + '/*.xsd'

        for xsd in glob.glob(path):
            mod = YModule(xsd)
            mod.parse()
            self.m_mods[mod.m_modname] = mod

            modname = mod.m_modname
            modtype = mod.m_modtype

            outfile = inDir + "/" + ypkcppname(modname) + ".h"
            logger.info("generate %s" % outfile)
            with open(outfile, 'w') as f:
                output = self.m_env.get_template('h_ymod').render(
                    ymod=mod, ybundle=self.m_bundle)
                f.write(output)

            outfile = inDir + "/" + ypkcppname(modname) + ".cpp"
            logger.info("generate %s" % outfile)
            with open(outfile, 'w') as f:
                output = self.m_env.get_template('cpp_ymod').render(
                    ymod=mod, ybundle=self.m_bundle)
                f.write(output)

        outfile = inDir + "/" + self.m_bundle + ".h"
        logger.info("generate %s" % outfile)
        with open(outfile, 'w') as f:
            output = self.m_env.get_template('h_bundle').render(
                ybundle=self.m_bundle, ymods=self.m_mods.values())
            f.write(output)

        outfile = inDir + "/" + self.m_bundle + ".cpp"
        logger.info("generate %s" % outfile)
        with open(outfile, 'w') as f:
            output = self.m_env.get_template('cpp_bundle').render(
                ybundle=self.m_bundle, ymods=self.m_mods.values())
            f.write(output)


cmddescription = 'generate cpp from dev yxsd model'


def makeoptions(optparser):
    optparser.add_argument(
        "--bundle",
        type=str,
        help="specify yang bundle")
    pass


def run(options):
    cmd = CmdYPK(options.input, options.bundle)
    cmd.run(options.output)


H_YMOD_TEMPLATE = """
//auto generated by xgen toolkit, bug mail to zengmao@fiberhome.com

#pragma once
#include "YPK.h"
#include "{{ymod.m_modname|pbname}}.pb.h"

using namespace YPK;

namespace {{ybundle}}
{

class YPK_API {{ymod.m_modname | ypkcppname}} : public YPK::YPKBase
{
public:
    virtual int YConfigGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc);
    virtual int YFilterGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc);
    virtual int YRpcGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc);
    virtual int YRpcRetGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pModule);
    virtual int YNotifyGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pModule);
    virtual int YPBGen(xmlNodePtr yNode, YPK::YPBMessagePtr pModule);

private:
{% for complextype in ymod.m_complex_types %}
  {% if complextype.m_modname %}
    int YXmlGen(const {{ybundle}}PB::{{ymod.m_modname | pbname}}::{{complextype.m_name_pb}} &st{{complextype.m_name_cpp}}, xmlNodePtr yNode);
    int YPBGen(const xmlNodePtr yNode, {{ybundle}}PB::{{ymod.m_modname | pbname}}::{{complextype.m_name_pb}} &st{{complextype.m_name_cpp}});

  {% endif %}
{% endfor%}
{% for complextype in ymod.m_complex_types %}
  {% if not complextype.m_modname %}
    int YXmlGen(const {{ybundle}}PB::{{ymod.m_modname | pbname}}::{{complextype.m_name_pb}} &st{{complextype.m_name_cpp}}, xmlNodePtr yNode);
    int YPBGen(const xmlNodePtr yNode, {{ybundle}}PB::{{ymod.m_modname | pbname}}::{{complextype.m_name_pb}} &st{{complextype.m_name_cpp}});

  {% endif %}
{% endfor %}

public:
{%for xsimple in ymod.m_simple_types %}
{%if xsimple is xSimpleTypeEnum %}
    struct {{xsimple.m_name | cppnormalize}} {
        enum {
{%  for xenum in xsimple.m_enums.values() %}
            {{xenum.m_en | cppnormalize}} = {{xenum.m_field_index}},
{%  endfor %}
        };

        static const char* name(int value) {
            switch (value) {
{%  for xenum in xsimple.m_enums.values() %}
            case {{xenum.m_field_index}}:
                return "{{xenum.m_en}}";
{%  endfor %}
            default:
                assert(false);
                return "invalid";
            }
        }

        static int value(std::string name) {
{%  for xenum in xsimple.m_enums.values() %}
            if (name == "{{xenum.m_en}}")
                return {{xenum.m_field_index}};
{%  endfor %}
            assert(false);
            return -1;
        }
    };
{%endif %}

{%endfor %}


};

}
"""


CPP_YMOD_BASE_TEMPLATE = """
//auto generated by xgen toolkit, bug mail to zengmao@fiberhome.com

{% set modname = ymod.m_modname %}
{% set modpbname = ymod.m_modname | pbname %}
{% set modpbtype = ymod.m_modtype | pbname %}
{% set modcppname = ymod.m_modname | ypkcppname %}
#include "{{modcppname}}.h"

using namespace YPK;
namespace {{ybundle}}
{


int {{modcppname}}::YConfigGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc)
{
    xmlNodePtr nodeConfig = xmlDocGetRootElement(yDoc);
    if (nodeConfig == NULL) {
        nodeConfig = xmlNewDocNode(yDoc, NULL, BAD_CAST "config", NULL);
        xmlDocSetRootElement(yDoc, nodeConfig);
    }

    {{ybundle}}PB::{{modpbname}}::{{modpbtype}} *pPtr = dynamic_cast<{{ybundle}}PB::{{modpbname}}::{{modpbtype}}*>(pModule.get());
    return YXmlGen(*pPtr, nodeConfig);
}

int {{modcppname}}::YFilterGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc)
{
    xmlNodePtr nodeFilter = xmlDocGetRootElement(yDoc);
    if (nodeFilter == NULL) {
        nodeFilter = xmlNewDocNode(yDoc, NULL, BAD_CAST "filter", NULL);
        xmlDocSetRootElement(yDoc, nodeFilter);
    }

    {{ybundle}}PB::{{modpbname}}::{{modpbtype}} *pPtr = dynamic_cast<{{ybundle}}PB::{{modpbname}}::{{modpbtype}}*>(pModule.get());
    return YXmlGen(*pPtr, nodeFilter);
}

int {{modcppname}}::YRpcGen(YPK::YPBMessagePtr pRpcPB, xmlDocPtr yDoc)
{
    std::string strMsgName = pRpcPB->GetTypeName();
{%for rpc in ymod.m_rpcs.values() %}
{%  if rpc.m_input %}
    if (strMsgName == "{{ybundle}}PB.{{modpbname}}.{{rpc.m_input|pbname}}") {
        {{ybundle}}PB::{{modpbname}}::{{rpc.m_input|pbname}} *pPtr = dynamic_cast<{{ybundle}}PB::{{modpbname}}::{{rpc.m_input|pbname}}*>(pRpcPB.get());
        xmlNodePtr nodeRpc = xmlNewDocNode(yDoc, NULL, BAD_CAST "{{rpc.m_name}}", NULL);
        xmlDocSetRootElement(yDoc, nodeRpc);
        xmlNsPtr pNs = xmlNewNs(nodeRpc, BAD_CAST "{{rpc.m_namespace}}", NULL);
        xmlSetNs(nodeRpc, pNs);
        return YXmlGen(*pPtr, nodeRpc);
    }
{%  else %}
    if (strMsgName == "{{ybundle}}PB.{{modpbname}}.{{rpc.m_name|pbname}}") {
        {{ybundle}}PB::{{modpbname}}::{{rpc.m_name|pbname}} *pPtr = dynamic_cast<{{ybundle}}PB::{{modpbname}}::{{rpc.m_name|pbname}}*>(pRpcPB.get());
        xmlNodePtr nodeRpc = xmlNewDocNode(yDoc, NULL, BAD_CAST "{{rpc.m_name}}", NULL);
        xmlDocSetRootElement(yDoc, nodeRpc);
        xmlNsPtr pNs = xmlNewNs(nodeRpc, BAD_CAST "{{rpc.m_namespace}}", NULL);
        xmlSetNs(nodeRpc, pNs);
        return 0;
    }
{%  endif %}

{%endfor %}
    return 0;
}

int {{modcppname}}::YRpcRetGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pPB)
{
    std::string strMsgName = pPB->GetTypeName();
{%for rpc in ymod.m_rpcs.values() %}
{%  if rpc.m_output %}
    if (strMsgName == "{{ybundle}}PB.{{modpbname}}.{{rpc.m_output|pbname}}") {
        {{ybundle}}PB::{{modpbname}}::{{rpc.m_output|pbname}} *pPtr = dynamic_cast<{{ybundle}}PB::{{modpbname}}::{{rpc.m_output|pbname}}*>(pPB.get());

        return YPBGen((xmlNodePtr)yDoc, *pPtr);
    }

{%  endif %}
{%endfor %}
    return 0;
}

int {{modcppname}}::YNotifyGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pPB)
{
    std::string strMsgName = pPB->GetTypeName();
{%for notify in ymod.m_notifys.values() %}
{%  if notify.m_type %}
    if (strMsgName == "{{ybundle}}PB.{{modpbname}}.{{notify.m_type|pbname}}") {
        {{ybundle}}PB::{{modpbname}}::{{notify.m_type|pbname}} *pPtr = dynamic_cast<{{ybundle}}PB::{{modpbname}}::{{notify.m_type|pbname}}*>(pPB.get());

        return YPBGen((xmlNodePtr)yDoc, *pPtr);
    }

{%  endif %}
{%endfor %}
    return 0;
}

int {{modcppname}}::YPBGen(xmlNodePtr yNode, YPK::YPBMessagePtr pModule)
{
    {{ybundle}}PB::{{modpbname}}::{{modpbtype}} *pPtr = dynamic_cast<{{ybundle}}PB::{{modpbname}}::{{modpbtype}}*>(pModule.get());
    return YPBGen(yNode, *pPtr);
}

{%for complextype in ymod.m_complex_types %}
{%set stmsg = 'st' + complextype.m_name_cpp %}

int {{modcppname}}::YXmlGen(const {{ybundle}}PB::{{modpbname}}::{{complextype.m_name_pb}} &{{stmsg}}, xmlNodePtr yNode)
{
    xmlNodePtr nodeLeaf = NULL;
  {% block mandgen scoped%}
  {% endblock %}

  {% block parentnoshared scoped%}
  {% endblock %}

  {% block xnode scoped%}
  {% endblock %}
    return 0;
}

int {{modcppname}}::YPBGen(xmlNodePtr yNode, {{ybundle}}PB::{{modpbname}}::{{complextype.m_name_pb}} &{{stmsg}})
{
    std::vector<xmlNodePtr> vecNodes;
    xmlNodePtr childNode;
{%  for field in complextype.m_fields %}
{%    if field.m_path and field.m_path[0] == '/' %}
{%      set fromself = 'true' %}
{%      set ypath = field.m_path[1:] %}
{%    else %}
{%      set fromself = 'false' %}
{%      set ypath = field.m_path %}
{%    endif %}
{%    if field.m_list %}
    YPK::selectNodes(yNode, "{{ypath}}", {{fromself}}, vecNodes);
    for (int i = 0; i < vecNodes.size(); i++) {
{%      if field.m_pbtype in ('int32', 'uint32', 'int64') %}
        {{stmsg}}.add_{{field.m_pbname}}(YInteger((const char*)getLeafNodeValue(vecNodes[i])));
{%      elif field.m_pbtype in ('uint64') %}
        {{stmsg}}.add_{{field.m_pbname}}(YUInteger((const char*)getLeafNodeValue(vecNodes[i])));
{%      elif field.m_pbtype == 'bytes' %}
        {{stmsg}}.add_{{field.m_pbname}}((const char*)getLeafNodeValue(vecNodes[i]));
{%      elif field.m_pbtype == 'enum' %}
        {{stmsg}}.add_{{field.m_pbname}}({{field.m_type | cppnormalize}}::value((const char*)getLeafNodeValue(vecNodes[i])));
{%      else %}
        xmlNodePtr xNode = vecNodes[i];
        YPBGen(xNode, *{{stmsg}}.add_{{field.m_pbname}}());
{%      endif %}
    }
{%    elif field.m_leaf %}
{%      if not ypath %}
    childNode = YPK::selectNode(yNode, "{{field.m_leafname}}", {{fromself}});
{%      elif ypath[-1] == '/' %}
    childNode = YPK::selectNode(yNode, "{{(ypath, field.m_leafname) | join}}", {{fromself}});
{%      else %}
    childNode = YPK::selectNode(yNode, "{{(ypath, '/', field.m_leafname) | join}}", {{fromself}});
{%      endif %}
    if (NULL != childNode) {
{%      if field.m_typename in ('int32', 'uint32', 'int64') %}
        {{stmsg}}.set_{{field.m_pbname}}(YInteger((const char*)getLeafNodeValue(childNode)));
{%      elif field.m_typename in ('uint64') %}
        {{stmsg}}.set_{{field.m_pbname}}(YUInteger((const char*)getLeafNodeValue(childNode)));
{%      elif field.m_typename == 'string' %}
        {{stmsg}}.set_{{field.m_pbname}}((const char*)getLeafNodeValue(childNode));
{%      elif field.m_typename == 'enum' %}
        {{stmsg}}.set_{{field.m_pbname}}({{field.m_type | cppnormalize}}::value((const char*)getLeafNodeValue(childNode)));
{%      else %}
    unkown leaf type {{field.m_typename}}
{%      endif %}
    }
{%    else %}
    childNode = selectNode(yNode, "{{ypath}}", {{fromself}});
    if (NULL != childNode) {
        YPBGen(childNode, *{{stmsg}}.mutable_{{field.m_pbname}}());
    }
{%    endif %}

{%  endfor %}
    return 0;
}

{%endfor %}


}
"""


CPP_YMOD_TEMPLATE = """
{% extends 'cpp_ymod_base' %}

{% macro createrootnode(path, indent) %}
{% set createrootnode | indent(indent*4, True )%}
xmlNodePtr {{path|nodecppname }} = xmlNewChild(yNode, NULL, BAD_CAST "{{path|nodename}}", NULL);
      {% for prefix,ns in ymod.m_namespaces.items() %}
        {% if prefix == ''%}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs({{path|nodecppname}}, BAD_CAST "{{ns}}", NULL);
        {% else %}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs({{path|nodecppname}}, BAD_CAST "{{ns}}", BAD_CAST "{{prefix}}");
        {%endif %}
xmlSetNs({{path|nodecppname}}, {{prefix|nsprefix}});
      {% endfor %}
{% endset %}
{{createrootnode-}}
{% endmacro %}

{% macro createparentpriv(nodeparent, field, indent) %}
{% set createparentpriv | indent(indent*4, True)%}
{% for path in field.m_path_priv %}
  {% if loop.first %}
    {% if path[0] == '/' %}
      {{-createrootnode(path, 0)}}
    {% else %}
xmlNodePtr {{path|nodecppname}} = xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{path}}", NULL);
    {% endif %}
  {% else %}
xmlNodePtr {{path|nodecppname}} = xmlNewChild({{loop.previtem|nodecppname}}, NULL, BAD_CAST "{{path}}", NULL);
  {% endif %}

  {% if loop.last and not field.m_list and not field.m_leaf%}
    {% for prefix, ns in field.m_namespaces.items() %}
        {% if prefix == ''%}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs({{path|nodecppname}}, BAD_CAST "{{ns}}", NULL);
        {% else %}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs({{path|nodecppname}}, BAD_CAST "{{ns}}", BAD_CAST "{{prefix}}");
        {% endif %}
xmlSetNs({{path|nodecppname}}, {{prefix|nsprefix}});
    {% endfor %}
  {% endif %}
{% endfor %}
{% endset %}
{{createparentpriv-}}
{% endmacro %}

{% macro createkeyleaf(stmsg, field, nodeparent, indent) %}
{% set createkeyleaf | indent(indent*4, True)%}
{%if field.m_nodeopr or field.m_namespaces%}
nodeLeaf = {% endif -%}
{%if field.m_typename in ('int32', 'uint32', 'int64') -%}
xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST YLexicalInteger({{stmsg}}.{{field.m_pbname}}()).c_str());
{%elif field.m_typename in ('uint64') -%}
xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST YLexicalUInteger({{stmsg}}.{{field.m_pbname}}()).c_str());
{%elif field.m_typename == 'string' -%}
xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST {{stmsg}}.{{field.m_pbname}}().c_str());
{%elif field.m_typename == 'enum' -%}
xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST {{field.m_type | cppnormalize}}::name({{stmsg}}.{{field.m_pbname}}()));
{%else -%}
    unkown leaf type {{field.m_typename}}
{%endif -%}
{%if field.m_namespaces %}
{%  for prefix, ns in field.m_namespaces.items() %}
{%    if prefix == ''%}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs(nodeLeaf, BAD_CAST "{{ns}}", NULL);
{%    else %}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs(nodeLeaf, BAD_CAST "{{ns}}", BAD_CAST "{{prefix}}");
{%    endif %}
xmlSetNs(nodeLeaf, {{prefix|nsprefix}});
{%  endfor %}
{%endif %}
{%if field.m_nodeopr -%}
if ({{stmsg}}.{{field.m_name|pbname}}_opr() != YPK::EDataNodeOpr::NONE) {
    xmlSetProp(nodeLeaf, BAD_CAST NC_OPERATION, BAD_CAST YPK::EDataNodeOpr::name({{stmsg}}.{{field.m_name|pbname}}_opr()));
}
{%endif -%}
{%endset -%}
{{createkeyleaf-}}
{% endmacro %}

{% macro createkeyleaf_key(stmsg, field, nodeparent, indent) %}
{% set createkeyleaf_key | indent(indent*4, True)%}
{%if field.m_nodeopr or field.m_namespaces%}
nodeLeaf = {% endif -%}
{%if field.m_typename in ('int32', 'uint32', 'int64') -%}
if ({{stmsg}}.{{field.m_pbname}}() != 0) {
	xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST YLexicalInteger({{stmsg}}.{{field.m_pbname}}()).c_str());
}
{%elif field.m_typename in ('uint64') -%}
if ({{stmsg}}.{{field.m_pbname}}() != 0) {
	xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST YLexicalUInteger({{stmsg}}.{{field.m_pbname}}()).c_str());
}
{%elif field.m_typename == 'string' -%}
if (!{{stmsg}}.{{field.m_pbname}}().empty()) {
	xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST {{stmsg}}.{{field.m_pbname}}().c_str());
}
{%elif field.m_typename == 'enum' -%}
xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_leafname}}", BAD_CAST {{field.m_type | cppnormalize}}::name({{stmsg}}.{{field.m_pbname}}()));
{%else -%}
    unkown leaf type {{field.m_typename}}
{%endif -%}
{%if field.m_namespaces %}
{%  for prefix, ns in field.m_namespaces.items() %}
{%    if prefix == ''%}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs(nodeLeaf, BAD_CAST "{{ns}}", NULL);
{%    else %}
xmlNsPtr {{prefix|nsprefix}} = xmlNewNs(nodeLeaf, BAD_CAST "{{ns}}", BAD_CAST "{{prefix}}");
{%    endif %}
xmlSetNs(nodeLeaf, {{prefix|nsprefix}});
{%  endfor %}
{%endif %}
{%if field.m_nodeopr -%}
if ({{stmsg}}.{{field.m_name|pbname}}_opr() != YPK::EDataNodeOpr::NONE) {
    xmlSetProp(nodeLeaf, BAD_CAST NC_OPERATION, BAD_CAST YPK::EDataNodeOpr::name({{stmsg}}.{{field.m_name|pbname}}_opr()));
}
{%endif -%}
{%endset -%}
{{createkeyleaf_key-}}
{% endmacro %}

{% macro createleaf(stmsg, field, nodeparent, indent) %}
{% set createleaf | indent(indent*4, True) %}
if ({{stmsg}}.has_{{field.m_pbname}}()) {
{% if field.m_path_priv %}
    {{-createparentpriv(nodeparent, field, 1)}}
    {{-createkeyleaf(stmsg, field, field.m_path_priv[-1]|nodecppname, 1)}}
{% else %}
    {{-createkeyleaf(stmsg, field, nodeparent, 1)-}}
{% endif %}
}
{% endset %}
{{createleaf-}}
{% endmacro %}


{%macro createlisto(stmsg, field, nodeparent, indent) %}
{%set createlistoo | indent(indent*4, True) %}
{%set nodevarname = field.m_path_priv_list|nodecppname %}
for (int i = 0; i < {{stmsg}}.{{field.m_pbname}}_size(); i++) {
{% if field.m_pbtype == 'bytes' %}
    xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_path_priv_list}}", BAD_CAST {{stmsg}}.{{field.m_pbname}}(i).c_str());
{% elif field.m_pbtype in ('int32', 'uint32', 'int64') %}
    xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_path_priv_list}}", BAD_CAST YLexicalInteger({{stmsg}}.{{field.m_pbname}}(i)).c_str());
{% elif field.m_pbtype in ('uint64')%}
    xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_path_priv_list}}", BAD_CAST YLexicalUInteger({{stmsg}}.{{field.m_pbname}}(i)).c_str());
{% elif field.m_pbtype == 'enum' %}
    xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_path_priv_list}}", BAD_CAST {{field.m_type | cppnormalize}}::name({{stmsg}}.{{field.m_pbname}}(i)));
{% else %}
    const {{ybundle}}PB::{{modpbname}}::{{field.m_pbtype}} &st{{field.m_name|cppname}} = {{stmsg}}.{{field.m_pbname}}(i);
    xmlNodePtr {{nodevarname}} =  xmlNewChild({{nodeparent}}, NULL, BAD_CAST "{{field.m_path_priv_list}}", NULL);
{%  for prefix, ns in field.m_namespaces.items() %}
{%    if prefix == '' %}
    xmlNsPtr {{prefix|nsprefix}} = xmlNewNs({{nodevarname}}, BAD_CAST "{{ns}}", NULL);
{%    else %}
    xmlNsPtr {{prefix|nsprefix}} = xmlNewNs({{nodevarname}}, BAD_CAST "{{ns}}", BAD_CAST "{{prefix}}");
{%    endif %}
    xmlSetNs({{nodevarname}}, {{prefix|nsprefix}});
{%  endfor %}
{%  if field.m_type_obj.m_fields_key %}
    if (st{{field.m_name|cppname}}.listopr() != YPK::EDataNodeOpr::NONE) {
        xmlSetProp({{nodevarname}}, BAD_CAST NC_OPERATION, BAD_CAST YPK::EDataNodeOpr::name(st{{field.m_name|cppname}}.listopr()));
    }
{%  endif %}
    YXmlGen(st{{field.m_name|cppname}}, {{nodevarname}});
{%  endif %}
}
{% endset %}
{{createlistoo-}}
{% endmacro %}

{% macro createlist(stmsg, field, nodeparent, indent) %}
{% set createlist | indent(indent*4, True) %}
if ({{stmsg}}.{{field.m_pbname}}_size() > 0) {
  {% if field.m_path_priv %}
    {{-createparentpriv(nodeparent, field, 1)}}
    {{-createlisto(stmsg, field, field.m_path_priv[-1] | nodecppname, 1)}}
  {% else %}
    {{-createlisto(stmsg, field, nodeparent, 1)}}
  {% endif %}
}
{% endset %}
{{createlist-}}
{% endmacro %}

{% macro createcontainer(stmsg, field, nodeparent, indent)%}
{% set createcontainer | indent(indent*4, True) %}
if ({{stmsg}}.has_{{field.m_pbname}}()) {
{% if field.m_path_priv %}
{{ createparentpriv(nodeparent, field, 1) }}
  {% if field.m_nodeopr %}
    if ({{stmsg}}.{{field.m_name|pbname}}_opr() != YPK::EDataNodeOpr::NONE) {
        xmlSetProp({{field.m_path_priv[-1]|nodecppname}}, BAD_CAST NC_OPERATION, BAD_CAST YPK::EDataNodeOpr::name({{stmsg}}.{{field.m_name|pbname}}_opr()));
    }

    if ({{stmsg}}.{{field.m_name|pbname}}_opr() != YPK::EDataNodeOpr::REMOVE) {
        YXmlGen({{stmsg}}.{{field.m_pbname}}(), {{field.m_path_priv[-1]|nodecppname}});
    }
  {% else %}
    YXmlGen({{stmsg}}.{{field.m_pbname}}(), {{field.m_path_priv[-1]|nodecppname}});
  {% endif %}
{% else %}
  {% if field.m_nodeopr %}
    if ({{stmsg}}.{{field.m_name|pbname}}_opr() != YPK::EDataNodeOpr::NONE) {
        xmlSetProp({{nodeparent}}, BAD_CAST NC_OPERATION, BAD_CAST YPK::EDataNodeOpr::name({{stmsg}}.{{field.m_name|pbname}}_opr()));
    }
    if ({{stmsg}}.{{field.m_name|pbname}}_opr() != YPK::EDataNodeOpr::REMOVE) {
        YXmlGen({{stmsg}}.{{field.m_pbname}}(), {{nodeparent}});
    }
  {% else %}
    YXmlGen({{stmsg}}.{{field.m_pbname}}(), {{nodeparent}});
  {% endif %}
{% endif %}
}
{% endset %}
{{createcontainer-}}
{% endmacro %}


{% macro fieldset(stmsg, nodeparent, field, indent) %}
{% if field.m_list %}
  {{-createlist(stmsg, field, nodeparent, indent)}}
{% elif field.m_leaf %}
  {{-createleaf(stmsg, field, nodeparent, indent)}}
{% else %}
  {{-createcontainer(stmsg, field, nodeparent, indent)}}
{% endif %}
{% endmacro %}



{% block xnode %}
{% for xnode in complextype.m_xtree.m_xnodes.values() recursive %}
  {% if loop.depth == 1 and xnode.m_xname[0] == '/' %}
    {{-createrootnode(xnode.m_xname, 1)}}
  {% else %}
{{loop.depth | myindent-}}
xmlNodePtr {{xnode.m_xname|nodecppname}} = xmlNewChild({{xnode.m_xname_parent|nodecppname}}, NULL, BAD_CAST "{{xnode.m_xname}}", NULL);
  {% endif %}
{{loop.depth | myindent-}}
{
  {% set outer_loop = loop %}
  {% for field in xnode.m_fields %}
  {{-fieldset(stmsg, xnode.m_xname|nodecppname, field, outer_loop.depth + 1)-}}
  {% endfor %}

  {% if xnode.m_xnodes %}
    {{-loop(xnode.m_xnodes.values())-}}
  {% endif %}
{{loop.depth | myindent-}}
}
{% endfor %}
{% endblock %}



{% block mandgen %}
{% for key,field in complextype.m_fields_key|dictsort %}
	{{-createkeyleaf(stmsg, field, 'yNode', 1)-}}
{% endfor %}
{% if complextype.m_fields_key%}
	if ({{stmsg}}.listopr() == YPK::EDataNodeOpr::REMOVE) {
		return 0;
	}

{% endif %}
{% for field in complextype.m_fields_mandatory %}
    {{-createkeyleaf(stmsg, field, 'yNode', 1)-}}
{% endfor %}
{% endblock %}



{% block parentnoshared %}
{% for field in complextype.m_fields_noshared %}
    {{-fieldset(stmsg, 'yNode', field, 1)-}}
{% endfor %}
{% endblock %}

"""


H_BUNDLE_TEMPLATE = """
//auto generated by xgen toolkit, bug mail to zengmao@fiberhome.com

#pragma once

#include "YPK.h"

{% for ymod in ymods %}
#include "{{ymod.m_modname|pbname}}.pb.h"
{% endfor %}

{% for ymod in ymods %}
#include "{{ymod.m_modname|ypkcppname}}.h"
{% endfor %}

namespace {{ybundle}}
{
int YPK_API YConfigGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc);
int YPK_API YFilterGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc);
int YPK_API YRpcGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc);
int YPK_API YRpcRetGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pModule);
int YPK_API YNotifyGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pModule);
int YPK_API YPBGen(xmlDocPtr yDoc, std::map<std::string, YPK::YPBMessagePtr> &mapModule);
int YPK_API YPBGen(xmlNodePtr xnode, YPBModuleMap &yPBModuleMap);
xmlDocPtr YPK_API ClearDocBlankNode(xmlDocPtr doc);
}
"""


CPP_BUNDLE_TEMPLATE = """
//auto generated by xgen toolkit, bug mail to zengmao@fiberhome.com
#include <boost/make_shared.hpp>
#include "{{ybundle}}.h"


namespace {{ybundle}}
{


int YConfigGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc)
{
    std::auto_ptr<YPKBase> pYPK;
    std::string strMsgName = pModule->GetTypeName();
{% for mod in ymods %}
  {% if loop.first %}
    if (strMsgName == "{{ybundle}}PB.{{mod.m_modname|pbname}}.{{mod.m_modtype|pbname}}") {
        pYPK.reset(new {{mod.m_modname | ypkcppname}}());
    }
  {% else %}
    else if (strMsgName == "{{ybundle}}PB.{{mod.m_modname|pbname}}.{{mod.m_modtype|pbname}}") {
        pYPK.reset(new {{mod.m_modname | ypkcppname}}());
    }
  {% endif %}
{% endfor %}
    else {
        pYPK.reset(new YPKBase());
    }

    return pYPK->YConfigGen(pModule, yDoc);
}


int YFilterGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc)
{
    std::auto_ptr<YPKBase> pYPK;
    std::string strMsgName = pModule->GetTypeName();
{% for mod in ymods %}
  {% if loop.first %}
    if (strMsgName == "{{ybundle}}PB.{{mod.m_modname|pbname}}.{{mod.m_modtype|pbname}}") {
        pYPK.reset(new {{mod.m_modname | ypkcppname}}());
    }
  {% else %}
    else if (strMsgName == "{{ybundle}}PB.{{mod.m_modname|pbname}}.{{mod.m_modtype|pbname}}") {
        pYPK.reset(new {{mod.m_modname | ypkcppname}}());
    }
  {% endif %}
{% endfor %}
    else {
        pYPK.reset(new YPKBase());
    }

    return pYPK->YFilterGen(pModule, yDoc);
}


int YRpcGen(YPK::YPBMessagePtr pModule, xmlDocPtr yDoc)
{
    std::auto_ptr<YPKBase> pYPK;
    std::string strMsgName = pModule->GetTypeName();

    do {
{%for mod in ymods%}
{%  if mod.m_rpcs %}
      if (strMsgName.find("{{ybundle}}PB.{{mod.m_modname|pbname}}") == 0) {
        pYPK.reset(new {{mod.m_modname | ypkcppname}}());
        break;
      }

{%  endif %}
{% endfor %}
        pYPK.reset(new YPKBase());
    } while (false);

    return pYPK->YRpcGen(pModule, yDoc);	
}

int YRpcRetGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pModule)
{
    std::auto_ptr<YPKBase> pYPK;
    std::string strMsgName = pModule->GetTypeName();

    do {
{%for mod in ymods%}
{%  if mod.m_rpcs %}
      if (strMsgName.find("{{ybundle}}PB.{{mod.m_modname|pbname}}") == 0) {
        pYPK.reset(new {{mod.m_modname | ypkcppname}}());
        break;
      }

{%  endif %}
{% endfor %}
        pYPK.reset(new YPKBase());
    } while (false);

    return pYPK->YRpcRetGen(yDoc, pModule);
}

int YPK_API YNotifyGen(xmlDocPtr yDoc, YPK::YPBMessagePtr pModule)
{
    std::auto_ptr<YPKBase> pYPK;
    std::string strMsgName = pModule->GetTypeName();

    do {
{%for mod in ymods%}
{%  if mod.m_notifys %}
      if (strMsgName.find("{{ybundle}}PB.{{mod.m_modname|pbname}}") == 0) {
        pYPK.reset(new {{mod.m_modname | ypkcppname}}());
        break;
      }

{%  endif %}
{% endfor %}
        pYPK.reset(new YPKBase());
    } while (false);

    return pYPK->YNotifyGen(yDoc, pModule);
}

static int YPBGen(xmlNodePtr xnode, YPBModuleMap &yPBModuleMap)
{
    YPK::YPBMessagePtr pModule;

    xmlNsPtr pNs = xmlSearchNs(NULL, xnode, NULL);
    if (NULL == pNs) {
        return -1;
    }

    std::string strNs((char *) pNs->href);
{%for mod in ymods %}
    if (strNs == "{{mod.namespace}}") {
        if (yPBModuleMap.find("{{mod.m_modname}}") != yPBModuleMap.end()) {
            pModule = yPBModuleMap["{{mod.m_modname}}"];
        }
        else {
            pModule = boost::make_shared<{{ybundle}}PB::{{mod.m_modname | pbname}}::{{mod.m_modname | pbname}}>();
            yPBModuleMap["{{mod.m_modname}}"] = pModule;
        }
        
        {{mod.m_modname | ypkcppname}} ypk;
        ypk.YPBGen(xnode, pModule);
        return 0;
    }

{%endfor%}

    return -1;
}

int YPBGen(xmlDocPtr yDoc, YPBModuleMap &mapModule)
{
    int iRet = 0;

    xmlNodePtr xRoot = xmlDocGetRootElement(yDoc);
    if (NULL == xRoot) {
        return 0;
    }

    xmlNodePtr xnode;
    YPK::YPBMessagePtr pModule;
    for (xnode = xmlFirstElementChild(xRoot); NULL != xnode; xnode = xmlNextElementSibling(xnode)) {
        YPBGen(xnode, mapModule);
    }
}

static bool IsBlankNode(xmlNodePtr pNode)
{
    if (pNode == NULL)
    {
        return true;
    }

    if (pNode->type == XML_ELEMENT_NODE && pNode->children == NULL)
    {
        return true;
    }
    else
    {
        return false;
    }
}

static void RecursiveBrotherChild(xmlNodePtr pDstNode)
{
    if (!IsBlankNode(pDstNode->children))
    {
        RecursiveBrotherChild(pDstNode->children);
    }
    else
    {
        xmlNodePtr pEarseNode = pDstNode->children;
        xmlUnlinkNode(pEarseNode);
        xmlFreeNode(pEarseNode);
    }

    if (!IsBlankNode(pDstNode->next))
    {
        RecursiveBrotherChild(pDstNode->next);
    }
    else
    {
        xmlNodePtr pEarseNode = pDstNode->next;
        xmlUnlinkNode(pEarseNode);
        xmlFreeNode(pEarseNode);
    }
}

xmlDocPtr YPK_API ClearDocBlankNode(xmlDocPtr doc)
{
    xmlDocPtr pDstDoc = xmlCopyDoc(doc, 1);
    RecursiveBrotherChild(xmlDocGetRootElement(pDstDoc));
    return pDstDoc;
}


}
"""
